	Include	"Stack Macros"***********************************************************************************                                       Written By*                                     Gordon Doughman*                                           For*                                  Motorola Semiconductor**         The author reserves the right to make changes to this file. Although this*         software has been carefully reviewed and is believed to be reliable, Motorola*         nor the author assumes any liability arising from its use. This software may*         be freely used and/or modified at no cost or obligation to the user.*************************************************************************************         This subroutine converts a 16-bit binary integer to an null terminated*         ASCII string. Three parameters are passed to the subroutine on the*         stack. The first parameter is the 16-bit binary number to be converted.*         The second parameter is the address of a buffer where the null terminated*         ASCII string will be placed. The buffer should be at least 7 bytes long.*         The third parameter is a boolean flag indicating whether the number passed*         in the first parameter is a signed or unsigned 16-bit number. If the byte*         flag is zero, the number is converted as an unsigned number. If the byte*         is non-zero, the number will be converted as a 16-bit signed number.*         Parameters are pushed onto the stack in the following order: 1.) Signed Flag;*         2.) Pointer to ASCII buffer; 3.) Number to be converted. A typical*         calling sequience would be:**         clra                   ; Do the conversion as an unsigned number.*         psha                   ; put the flag on the stack.*         ldd    #Buffer         ; get the address of the ascii buffer.*         pshd                   ; put the address on the stack.*         ldd    Num             ; Get the number to convert.*         pshd                   ; Put it on the stack*         jsr    Int2Asc         ; Go convert the number.*         .*         .*         .**         This subroutine has two local variables. The first, zs, is a boolean variable*         used to supress leading zeros when doing a conversion. It is located at an*         offset of 0 from the stack frame pointer. The second local, Divisor, is a 16-bit*         variable. It is used to divide the number being converted by succeedingly lower*         powers of 10. Divisor is located at an offset of 1 from the local stack frame*         pointer.**         NOTE: This routine was written assuming that the previous stack frame pointer*         is the x-index register. HOWEVER, because the x-index register is required*         by the integer divide instruction, the y-index register is used as the*         stack frame pointer WITHIN the Int2Asc subroutine.***         Declare locals*PCSave	set	*		; save the current PC value	org	0		; set PC to 0 for offsets to localszs	rmb	1		; declare zs variable.Divisor	rmb	2		; declare Divisor variable.LocSize	set	*		; number of bytes of local storage.	org	PCSave**         Offsets to parameters*Num	equ	LocSize+4		; offset to Num parameter.BuffP	equ	LocSize+6		; offset to BuffP parameter.Signed	equ	LocSize+8		; offset to Signed parameter.*Int2Asc	equ	*	pshx			; save the previous stack frame pointer.	ldd	#10000		; initialize the divisor to 10000.	pshd	clra			; initialize zs to 0.	psha	tsy			; initialize the new stack frame pointer.	ldd	num,y		; get the number to convert. Is it zero?	bne	Int2Asc1		; no go do the conversion.	ldd	#$3000		; yes.	ldx	BuffP,y		; point to the buffer.	std	0,y		; just put an ASCII 0 in the buffer.	bra	Int2Asc5		; then return.Int2Asc1	tst	Signed,y		; do the conversion as a signed number?	beq	Int2Asc2		; no.	tsta			; yes. Is the number negative?	bpl	Int2Asc2		; no. just go do the conversion.	coma			; yes. make it a positive number by negation.	comb	addd	#$1	std	Num,y		; save the result.	ldaa	#'-'		; get an ASCII minus sign.	ldx	BuffP,y		; point to the buffer.	staa	0,x		; put it in the buffer.	inx			; point to the next location in the buffer.	stx	BuffP,y		; save the new pointer value.Int2Asc2	ldd	Num,y		; get the remainder to convert.	ldx	Divisor,y	idiv	std	Num,y		; save the remainder.	xgdx			; put the dividend into d.	tstb			; was the dividend 0?	bne	Int2Asc3		; no. go store the number in the buffer.	tst	zs,y		; are we still supressing leading zeros?	beq	Int2Asc4		; yes. go setup for the next divide.Int2Asc3	addb	#'0'		; make the dividend ASCII.	ldaa	#1	staa	zs,y		; don't supress leading zeros anymore.	ldx	BuffP,y		; get a pointer to the buffer.	stab	0,x		; save the digit.	inx			; point to the next location.	stx	BuffP,y		; save the new pointer value.Int2Asc4	ldd	Divisor,y		; get the previous divisor.	ldx	#10	idiv			; divide it by 10.	stx	Divisor,y		; save the dividend. Is it zero?	bne	Int2Asc2		; no. continue with the conversion.	ldx	BuffP,y		; get a pointer to the buffer.	clr	0,x		; null terminate the string.	tsx			; this is only needed because we are using y as our sf pointer.Int2Asc5	rtdx	LocSize		; return & deallocate locals & parameters.*************************************************************************************         This subroutine performs a 16 x 16 bit unsigned multiply and produces a 32-bit*         result. Two 16-bit numbers are passed to the subroutine on the stack.*         The 32-bit result is returned on the stack in place of the two 16-bit*         parameters. This allows the calling routine to easily pull the product*         from the stack and store the result. Because multiplication is a*         commutative operation, the order in which the paramerers are pushed*         onto the stack is unimportant. A typical calling sequience would be:**         ldd       Num1*         pshd*         ldd       Num2*         pshd*         jsr       Mul16x16*         puld*         std       Result32*         puld*         std       Result32+2*         .*         .*         .**         This subroutine has four local variables. Each variable occupies 1 byte*         on the stack. These four bytes are used to hold the partial product as*         the final answer is being computed. These four byte variables are*         treated as 16-bit variables during the calculation.**         NOTE: This routine was written assuming that the stack frame pointer*         is the x-index register.**         Declare locals*PCSave	set	*		; save the current PC value	org	0		; set PC to 0 for offsets to localsPrd0	rmb	1		; declare ms byte of partial product variable.Prd1	rmb	1		; declare next ms byte of partial product variable.Prd2	rmb	1		; declare next ls byte of partial product variable.Prd3	rmb	1		; declare ls byte of partial product variable.LocSize	set	*		; number of bytes of local storage.	org	PCSave**         Offsets to parameters*Fact1	equ	LocSize+4		; offset to factor 1 parameter.Fact2	equ	LocSize+6		; offset to factor 2 parameter.*	cycles	clear*Mul16x16	equ	*	pshx			; save the previous stack frame pointer.	clrd			; clear the d-accumulator.	pshd			; allocate & initialize the locals prd0 - prd3	pshd	tsx			; initialize the new stack frame pointer.	ldaa	Fact1+1,x		; get the ls byte of factor 1.	ldab	Fact2+1,x		; get the ls byte of factor 2.	mul			; multiply them.	std	Prd2,x		; save the first term of the partial product.	ldaa	Fact1,x		; get the ms byte of factor 1.	ldab	Fact2+1,x		; get the ls byte of factor 2.	mul			; multiply them.	addd	Prd1,x		; add the result into the partial product.	std	Prd1,x		; save the result.	ldaa	Fact1+1,x		; get the ls byte of factor 1.	ldab	Fact2,x		; get the ms byte of factor 2.	mul			; multiply them.	addd	Prd1,x		; add the result into the partial product.	std	Prd1,x		; save the result.	bcc	Mul16		; Was there a carry into Prd0?	inc	Prd0,x		; yes. 'add' it in.Mul16	ldaa	Fact1,x		; get the ms byte of factor 1.	ldab	Fact2,x		; get the ms byte of factor 2.	mul			; multiply them.	addd	Prd0,x		; add it to the partial product.	std	Fact1,x		; overwrite the two parameters with the result.	ldd	Prd2,x	std	Fact2,x	rtd	x,LocSize		; return and deallocate the locals.*	cycles	total=		; Total number of E cycles for a 16 x 16 multiply.***********************************************************************************         This subroutine performs a 32 by 16 bit unsigned divide and produces a 32-bit*         quotient and a 16-bit remainder. Both the divisor and dividend are passed to*         the subroutine on the stack. The 32-bit quotient and 16-bit remainder are*         returned on the stack in place of the divisor and dividend. This allows the*         calling routine to easily pull the answer from the stack and store the result.*         The divisor is pushed onto the stack first followed by the lower 16-bits of*         the dividend and finally the upper 16-bits of the dividend. A typical calling*         sequience would be:**         ldd       Divisor*         pshd*         ldd       Dividend+2*         pshd*         ldd       Dividend*         pshd*         jsr       Div32x16*         puld*         std       Quotient*         puld*         std       Quotient+2*         puld*         std       Remainder*         .*         .*         .***         This subroutine has two local variables. A 32-bit variable for partial quotient*         results that is treated as two 16-bit variables and a 16-bit variable for*         intermediate remainder results.**         NOTE: This routine was written assuming that the previous stack frame pointer*         is the x-index register. HOWEVER, because the x-index register is required*         by the integer and fractional divide instructions, the y-index register is*         used as the stack frame pointer WITHIN the Div32x16 subroutine.**         Declare locals*PCSave	set	*		; save the current PC value.	org	0		; set PC to 0 for offsets to locals.Quo0	rmb	2		; declare upper 16-bits of quotient.Quo2	rmb	2		; declare lower 16-bits of quotient.Rem	rmb	2		; declare remainder.LocSize	set	*		; number of bytes of local storage.	org	PCSave**         Offsets to parameters*Num0	equ	LocSize+4		; upper 16-bits of Dividend.Num2	equ	LocSize+6		; lower 16-bits of Dividend.Denm	equ	LocSize+8		; 16-bit divisor.*	cycles	clear*Div32x16	equ	*	pshx			; save the previous stack frame pointer.	clrd			; clear the d-accumulator.	pshd			; allocate & initialize the locals.	pshd	pshd	tsy			; initialize y as the new stack frame pointer.	ldd	Num0,y		; load the upper 16-bits of the dividend.	cpd	Denm,y		; is the divisor > the upper 16-bits of the dividend?	blo	Div32x16a		; yes. use a fractional divide on the initial value.	ldx	Denm,y		; load the divisor into x.	idiv			; divide the upper 16 bits by the divisor.	stx	Quo0,y		; save the partial quotient.Div32x16a	ldx	Denm,y		; load the divisor into x.	fdiv			; resolve the remainder into a 16-bit fractional part.	stx	Quo2,y		; save the partial result.	std	Rem,y		; save the remainder of the fractional divide (partial remainder).	ldd	Num2,y		; get the lower 16-bits of the dividend.	ldx	Denm,y		; get the denominator again.	idiv			; resolve the remaining quotient.	addd	Rem,y		; add the previous remainder to this remainder.	std	Rem,y		; save the total remainder.	xgdx			; put the last partial quotient into the d-accumulator...				; & save the total remainder in x.	addd	Quo2,y		; add partial quoient to the lower 16-bits of the quotient.	std	Num2,y		; save the result.	ldd	Quo0,y		; get the upper 16-bits of the quotient.	adcb	#0		; add the possible carry to the lower 8-bits.	adca	#0		; add the possible carry to the upper 8-bits.	std	Num0,y		; save the result.	xgdx			; get the total remainder back into d.	cmpd	Denm,y		; is the total fractional remainder > the divisor?	blo	Div32x16b		; no. we're finished.	subd	Denm,y		; yes. It will be < than 2*Divisor.	std	Rem,y		; save the final remainder.	ldd	Num2,y		; now we must add 1 to the 32-bit quotient.	addd	#1		; add 1 to the lower 16-bits.	std	Num2,y		; save the result.	ldd	Num0,y		; get the upper 16-bits.	adcb	#0		; add the possible carry to the lower 8-bits.	adca	#0		; add the possible carry to the upper 8-bits.	std	Num0,y		; save the result.Div32x16b	ldd	Rem,y		; get the final remainder.	std	Denm,y		; overwrite the divisor.	tsx			; need to do this for rtd to work correctly. See NOTE.	rtd	x,LocSize		; deallocate locals & return.*	cycles	total=		; Total number of E cycles for a 32 x 16 divide.*